# blitcurve

A description of this package.


## Linking blitcurve (Xcode)

1.  Add a dependency on blitcurve.  File->Swift Packages->Add Package Dependencies...
2.  In your target settings, add blitcurve to your "Frameworks, Libraries, and Embedded Content".

### Linking the metal version

Blitcurve is cross-compiled: there's a C version and a metal shader version.
To add the metal shader version, you need to link it into the same target that contains your `.metal` files.  This is a limitation of Xcode, see `FB7744335`.


1.  add a 'run script phase' to the target with these contents:
```bash
set -e
for v in ${HEADER_SEARCH_PATHS[@]}; do
echo $v notfound
if [[ $v == *"blitcurve"* ]]; then
  (
   SDKROOT=""
   $v/../../../makemetal.swift
  )
  
fi
done
```
Note that the script phase:
   1.  Must be before the "compile sources" phase
   2.  Must have an Output File of `${SRCROOT}/blitcurve.metal` for your builds to be reliable
   
1.  Add `${HEADER_SEARCH_PATHS}` to the "Metal Compiler - Build Options - Header Search Paths" setting.  *Note that the metal compiler option is different than the setting for other languages!*
2.  The first time you build your project, blitcurve.metal will be dropped into your source directory.  Drag this into xcode.  You do **not** need to check "copy source files", since it will be autogenerated by the build script.
3.  You may want to add `blitcurve.metal` to your `.gitignore`

## SwiftUI 

Many types embed a `View` type which is a SwiftUI view.

```swift
let cubic = Cubic(a: .zero, b: SIMD2<Float>(20,10),c: SIMD2<Float>(7,7),d: SIMD2<Float>(5,5))
struct Demo: View {
    var body: some View {
        ZStack {
            Cubic.View(cubic).scale(by: 5)
        }
        
    }
}
```


For more, see the [Playgrounds](/Playgrounds) folder.


## Drawing curves

Assuming some familiarity with metal, here is an example of how to draw an array of BCCubic.

You may be familiar with [prior work on curve flattening](https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html). We use the same general idea, however
1.  In this example, we use a constant number of vertices per cubic, rather than determining per-curve.  In practice, I often want to relate this number to the transform.
2.  We send the whole curve down to the GPU, and do the 'flattening' in a vertex shader.

```swift
func draw(in encoder: MTLRenderCommandEncoder, transform: float3x3) {
    encoder.setRenderPipelineState(pipelineState)
    
    encoder.setVertexBytes(v: transform, index: 0)
    let vertexesPerCubic: UInt8 = 15
    encoder.setVertexBytes(v: vertexesPerCubic, index: 1)
    encoder.setVertexBuffers([cubicBuffer], range: 2..<3)
    encoder.drawPrimitives(type: .lineStrip, vertexStart: 0, vertexCount: Int(vertexesPerCubic), instanceCount: cubicBuffer.count)
}
```

```metal
#import <blitcurve.h>
using namespace metal;
typedef struct  {
    float4 position [[position]];
} VertexOutput;
vertex VertexOutput VertexShader(ushort vertexID [[vertex_id]], ushort instanceID [[instance_id]], float3x3 constant &transform, uint8_t constant &vertexesPerCubic, BCCubic device *cubics) {
    VertexOutput output;
    BCCubic cubic = cubics[instanceID];
    
    output.position = simd_float4(0, 0, 1, 1);
    output.position.xy = BCCubicEvaluate(cubic, BCVertexToBezierParameter(vertexID, vertexesPerCubic));
    output.position.xyz = output.position.xyz * transform;
    return output;
   
}
fragment float4 VertexShader(VertexOutput f [[stage_in]]) {
    return simd_float4(1,1,1,1);
}
```
